<p>Before reading this article, I would recommend you go through <a href="https://noma.substack.com/p/a-primer-on-defi-market-design">A primer on DeFi market design</a> and the <a href="https://uniswap.org/whitepaper-v3.pdf">Uniswap v3 whitepaper</a> or <a href="https://twitter.com/hosseeb/status/1374762151491989509">Haseeb Qureshi’s tweet thread</a></p><h3>Submit strategies not trades</h3><p>In a TradFi orderbook, strategies are computed off-exchange. You run the strategy off-chain, you get a whole bunch of values (in real time) as to where to place your limit orders, and you send these values to the exchange. Executions happen on-exchange. Information changes, you make new computations off-exchange, you send requests on-exchange to cancel the old values and submit new values.</p><p>In DeFi, however, due to computing constraints, the more efficient model is submit the strategy itself on-chain. Anyone can compute what your strategy does off-chain, this is infinitely cheaper as compared to running it on-chain. Only when someone wants to actually fill your orders do they pay for on-chain computation of your strategy.</p><h3>Vaults for popular strategies</h3><p>The other major lesson in DeFi design is that if multiple people want to follow the same strategy, they save gas if they pool. Imagine if every liquidity provider had to deploy their own contract for their own isolated pool. Then users who have to pay separately for on-chain computation for every liquidity provider they wanted to trade with, separately.</p><p><em>[To a limited extent, this is what happens in Uniswap v3. Instead of pooling all liquidity providers together, liquidity providers are pooled only if they belong to the same tick. Traders need to pay gas separately for every tick they match.]</em></p><p>Instead you use a vault pattern. Users deposit assets, and get tokenised representations of their assets. These assets can then be involved in arbitrarily complex interactions, socialing gas costs across the pool. And at the end, users can use these tokenised representation to withdraw the assets.</p><p>As long as the following “vault gas equation” holds, it makes sense for the n users to pool together into a single pool and execute the same strategy collectively.</p><p><code>Gas(deposit) + Gas(strategy#) / n + Gas(withdraw) &lt; Gas(strategy)</code></p><p>The more distinct users who want to use this strategy, the more gas they save if they pool up instead of act individually. </p><p><code>This means you should make pools for those strategies that many people want to execute.</code></p><h3>(#)Mid-scale computation increases gas costs for pools</h3><p><em>You may skip this section if you like.</em></p><p>An individual user can submit new values for their strategy during execution of their strategy. Suppose a market-maker wants to periodically change the price range in which they provide liquidity. They want to make this change once in six hours, or perhaps whenever volatility changes significantly. They can check this condition off-chain, and only submit the final values on-chain.</p><p>A strategy followed by a vault, however, cannot require such values, since the users may not trust each other to submit the correct values. All values must be submitted beforehand, or a strategy to compute those values in real time must be provided before hand. This increases gas cost when using a vault that requires such computation.</p><p>There may exist other means to submit these values such as an <a href="https://docs.umaproject.org/getting-started/oracle">optimistic oracle</a>. You can ask a user to provide a bond and trust them to provide correct values. If the values are right, you get the full gas savings as if the vault was a single trader. If the values are wrong, you force on-chain computation and slash their bond.</p><h3>Pooling in on-chain spot exchanges</h3><p>Uniswap trades have two sides - the liquidity providers (limit order) and the liquidity takers (market order). Liquidity providers use a complex strategy for market-making. A deposit-act-withdraw scheme is used and they are pooled. Liquidity takers on the other hand, all act independently. Why are they not pooled? It has so far been assumed that traders on the other side all have unique strategies and therefore cannot be pooled. Let’s see if this is true.</p><p>If someone wants to deploy the strategy “market buy x ETH right now”, there is no way to pool such a strategy, because “right now” is something that varies from time to time. No two users will have the same “right now” unless they trade in the same block, and even within the same block, their trades might execute at different positions and therefore different prices. However, a strategy such as “buy x ETH at the end of this hour“ is something that multiple users may want to do - this can be pooled. Have a vault that accepts deposits and tokenises them. At the end of the hour, have anyone trigger a single swap. Then allow withdrawals. As long as the vault gas equation holds, this is worth doing.</p><h3>Where is this most useful? - A case study in TWAPs</h3><p>We can use this for <em>any </em>strategy that is popular but consumes sufficient gas. An example of a very popular strategy that would consume a lot of gas is a TWAP order. A TWAP order is one where your trade is split into many small chunks, each of which is executed in some interval. For instance if you want to buy 1000 ETH, you could buy 1 ETH every minute for 1000 minutes. This a popular strategy in TradFi as it smooths out your entry price. As you keep filling available liquidity, you also provide the liquidity providers with sufficient time to provide more liquidity. This way you avoid moving price too much and get a decent average entry price.</p><p>This strategy would consume a lot of gas if undertaken individually. However, if multiple users want to engage in the same strategy over the same time period (t1 = 1000 min) with the same smaller time intervals (t2 = 1 min) for each trade, then they can pool together and execute it. Every smaller time interval (t2), you have a user who is provided a tiny incentive to trigger the trade as described in mid-scale computation.</p><h3>Efficienct pool-to-pool matching</h3><p>The above strategy is an example of a pool-to-pool trade. One pool is the TWAP pool, the other is the uniswap pool. Liquidity providers in the uniswap pool are saving gas by forming a single pool. TWAP buyers are saving gas by forming a single pool.</p><p>Can we save even more gas? Yes, we can, if both pools are compatible for it.</p><p>Consider a TWAP buy pool and a TWAP sell pool. The TWAP buy pool will buy 1000 ETH by buying 1 ETH every minute for 1000 minutes. The TWAP sell pool will sell 1000 ETH by selling 1 ETH every minute for 1000 minutes.</p><p>Instead of both pools interacting with uniswap, they can directly interact with each other. With one single interaction, you can “lock” both pools into each other. No interactions need to happen during the 1000 minutes. At the end of the 1000 minutes, you can compute the TWAP of the uniswap price - and automatically swap both pools based on this price. This is a single interaction. You have now executed two batched sets of TWAPs against each other, without actually having to execute either of them on a per-trade basis.</p><p>If one of the pools is in excess, it may still have to go to uniswap to be executed. However, the price impact is lesser. The smaller pool however has saved a lot of gas.</p><p>Such matching can also be done between TWAPs that operate at different time intervals t1 and t2. For instance a pool that wishes to market buy for 3 hours can be partially matched against one that wishes to market sell for 6 hours. The 3 hour pool saves all its gas cost and the 6 hour pool saves half of it (or more, if it matches against the next 3 hour pool as well).</p><p>A pool that wishes to market buy every 5 minutes can be partially matches against one that wishes to market buy every 10 minutes. The 5 minute pool saves all its gas cost and 10 minute pool saves half of it (since it has to make half as many trades on uniswap).</p><h3>Composability</h3><p>Composability is essential to ensure and plan careful when doing pool to pool matching. For instance in TWAP orders we identified three parameters as important to characterise - t1, t2 and the size of the pool. Since TWAP orders are typically liquidity takers, they do not charge fees. A market-making pool on the other hand typically has parameters as - fees, size of the pool and one or two price points that characterise the strategy of the pool.</p><p>Tick-based batching is a careful consideration made by Uniswap v3 to maximise composability between what is essentially p^2 different pools where each liquidity provider picks two values (p1,p2) each of which has p options. Having three fee tiers (no more, no less) is another such decision.</p><p>Similar smart techniques will have to be have to be employed for any pool-to-pool matching, whether both pools are on the same side of the trade or on opposite sides. In Uniswap these tactics are only used to pool people on one side of the trade.</p>